<html><head><title>File::Type</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.01,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008002 at Thu Aug  5 13:56:36 2004 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>File::Type - Determine a file&#39;s contents by looking at the name and contents</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre lang='und' xml:lang='und'>   use File::Type qw( get_type type_2_mime ) ;

   File::Type::load_magic( &#34;type_file&#34; ) ;
   File::Type::load_magic( \@type_defs ) ;

   my $file_type = get_type( &#34;foo.pl&#34; ) ;

   print type_2_mime( $file_type ) ;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A perl module that acts a lot like the traditional Unix <code lang='und' xml:lang='und'>file</code> command, but using regular expressions to do the job.</p>

<p>File types are defined in a data structure that&#39;s passed in or in a file that contains such a data structure. Default file types are defined in the module, so you don&#39;t need to <code lang='und' xml:lang='und'>load_magic()</code> in some cases.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h2>

<dl>
<dt><a name="add_magic"
>add_magic</a></dt><p class="pad"></p>

<dd>Adds more types to the current magic database.</dd><p class="pad"></p>

<dd>NOT IMPLEMENTED</dd><p class="pad"></p>

<dd>#############################</dd><p class="pad"></p>

<dt><a name="add_mime_types"
>add_mime_types</a></dt><p class="pad"></p>

<dd>Adds the contents of a mime types file to the current magic database.</dd><p class="pad"></p>

<dt><a name="load_magic"
>load_magic</a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>load_magic()</code> takes either a file name or a reference to an array and sets up the internal data structures needed by <code lang='und' xml:lang='und'>get_type()</code> and <code lang='und' xml:lang='und'>type_2_mime()</code>. See the source code for the module for more information on the data structure required.</dd><p class="pad"></p>

<dd>The types included with this module are not that comprehensive, since Safari needs to know about very few of them. Submissions of new and better recognizers are appreciated.</dd><p class="pad"></p>

<dt><a name="get_type"
>get_type</a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>get_type()</code> does three levels of check and returns the result of the first sucessful check.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>get_type()</code> first stats the file, then looks at it&#39;s extension, then looks inside the file using regular expressions. Since perl5 regular expressions are pretty darn comprehensive, this should allow complete emulation of the magic files used by the Unix <code lang='und' xml:lang='und'>file</code> command as well as the language identification heuristics.</dd><p class="pad"></p>

<dd>If a second argument is provided, it will be used as the file&#39;s contents, and the file will not be opened. The contents must be from the beginning of the file for most binary file types, and should be for most text file types. As much data as is feasible should be provided.</dd><p class="pad"></p>

<dt><a name="type_2_mime"
>type_2_mime</a></dt><p class="pad"></p>

<dd>Takes the result from a get_type call and returns the corresponding mime_type.</dd><p class="pad"></p>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MAGIC_DATA_STRUCTURE"
>MAGIC DATA STRUCTURE</a></h2>

<p>The format of the magic data structure is:</p>

<pre lang='und' xml:lang='und'>   {
      &#39;file type&#39; =&#62; [  # reported when a match is found
         [
           &#39;long type&#39;    # Unix find-like description
           &#39;mime type&#39;,   # used to translate file type to mime type
         ],
         name_test,     # the test applied when only the file name is known
         guts_test_1,   # the first test applied if the file name test fails.
         guts_test_2,   # the second test applied if guts_test_1 fails
         ...
      ],
      &#39;another type&#39; =&#62; [
         ...
      ],
      ...
  }</pre>

<p>See <code lang='und' xml:lang='und'>file_type</code> for a description of the testing algorithm.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Primitive_tests"
>Primitive tests</a></h2>

<p>These functions may be used in the magic data structure as complete tests or as part of other tests.</p>

<p>The text / binary primitives only test the file state once and cache the results.</p>

<dl>
<dt><a name="abort"
>abort</a></dt><p class="pad"></p>

<dd>Aborts all testing by dieing with the message passed.</dd><p class="pad"></p>

<dt><a name="debug"
>debug</a></dt><p class="pad"></p>

<dd>Prints a message if debugging is enabled.</dd><p class="pad"></p>

<dt><a name="has_extension"
>has_extension</a></dt><p class="pad"></p>

<dd>Returns 1 if the file name has an extension matching any of the arguments</dd><p class="pad"></p>

<dt><a name="is_text"
>is_text</a></dt><p class="pad"></p>

<dd>Returns 1 if the file is text, 0 if it is not.</dd><p class="pad"></p>

<dt><a name="is_binary"
>is_binary</a></dt><p class="pad"></p>

<dd>Returns 1 if the file is not text, 0 if it is.</dd><p class="pad"></p>

<dt><a name="match_and_score"
>match_and_score</a></dt><p class="pad"></p>

<dd>Returns a score based on where and how many of the words or regular expression arguments match. This is the routine used internally when a word list or a regular expression is used in the magic structure.</dd><p class="pad"></p>

<dt><a name="matches_name"
>matches_name</a></dt><p class="pad"></p>

<dd>Returns 1 if the file name matches the regular expression or strings passed in.</dd><p class="pad"></p>

<dt><a name="must_be_text"
>must_be_text</a></dt><p class="pad"></p>

<dd>Returns -1 if the file is not text (according to -T), 0 if it is. This is used to disqualify a type for a file without scoring the file, since 0 means &#39;can&#39;t tell&#39;, and -1 means it&#39;s not that type.</dd><p class="pad"></p>

<dt><a name="must_be_binary"
>must_be_binary</a></dt><p class="pad"></p>

<dd>Returns -1 if the file is text (according to -T), 0 otherwise.</dd><p class="pad"></p>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Barrie Slaymaker</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="POD_ERRORS"
>POD ERRORS</a></h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>
<dt><a name="Around_line_451:"
>Around line 451:</a></dt><p class="pad"></p>

<dd>You forgot a &#39;=back&#39; before &#39;=head2&#39;</dd><p class="pad"></p>
</dl>

<!-- end doc -->

</body></html>
