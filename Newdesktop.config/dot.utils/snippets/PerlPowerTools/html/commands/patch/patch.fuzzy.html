<html><head><title>patch</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.01,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008002 at Thu Aug  5 13:56:31 2004 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>patch - apply a diff file to an original</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p><b>patch</b> [options] [origfile [patchfile]] [+ [options] [origfile]]...</p>

<p>but usually just</p>

<p><b>patch</b> &#60;patchfile</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><i>Patch</i> will take a patch file containing any of the four forms of difference listing produced by the <i>diff</i> program and apply those differences to an original file,
producing a patched version.
By default,
the patched version is put in place of the original,
with the original file backed up to the same name with the extension &#34;.orig&#34; [see <a href="#note_1" class="podlinkpod"
>&#34;note 1&#34;</a>],
or as specified by the <b>-b</b>,
<b>-B</b>,
or <b>-V</b> switches.
The extension used for making backup files may also be specified in the <b>SIMPLE_BACKUP_SUFFIX</b> environment variable,
which is overridden by above switches.</p>

<p>If the backup file already exists,
<b>patch</b> creates a new backup file name by changing the first lowercase letter in the last component of the file&#39;s name into uppercase.
If there are no more lowercase letters in the name,
it removes the first character from the name.
It repeats this process until it comes up with a backup file that does not already exist.</p>

<p>You may also specify where you want the output to go with a <b>-o</b> switch; if that file already exists,
it is backed up first.</p>

<p>If <i>patchfile</i> is omitted,
or is a hyphen,
the patch will be read from standard input.</p>

<p>Upon startup,
patch will attempt to determine the type of the diff listing,
unless over-ruled by a <b>-c</b>,
<b>-e</b>,
<b>-n</b>,
or <b>-u</b> switch.
Context diffs [see <a href="#note_2" class="podlinkpod"
>&#34;note 2&#34;</a>],
unified diffs,
and normal diffs are applied by the <i>patch</i> program itself,
while ed diffs are simply fed to the <i>ed</i> editor via a pipe [see <a href="#note_3" class="podlinkpod"
>&#34;note 3&#34;</a>].</p>

<p><i>Patch</i> will try to skip any leading garbage,
apply the diff,
and then skip any trailing garbage.
Thus you could feed an article or message containing a diff listing to <i>patch</i>,
and it should work.
If the entire diff is indented by a consistent amount,
this will be taken into account.</p>

<p>With context diffs,
and to a lesser extent with normal diffs,
<i>patch</i> can detect when the line numbers mentioned in the patch are incorrect,
and will attempt to find the correct place to apply each hunk of the patch.
A linear search is made for a place where all lines of the context match.
The hunk is applied at the place nearest the line number mentioned in the diff [see <a href="#note_4" class="podlinkpod"
>&#34;note 4&#34;</a>].
If no such place is found,
and it&#39;s a context diff,
and the maximum fuzz factor is set to 1 or more,
then another scan takes place ignoring the first and last line of context.
If that fails,
and the maximum fuzz factor is set to 2 or more,
the first two and last two lines of context are ignored,
and another scan is made.
(The default maximum fuzz factor is 2.) If <i>patch</i> cannot find a place to install that hunk of the patch,
it will put the hunk out to a reject file,
which normally is the name of the output file plus &#34;.rej&#34; [see <a href="#note_1" class="podlinkpod"
>&#34;note 1&#34;</a>].
The format of the rejected hunk remains unchanged [see <a href="#note_5" class="podlinkpod"
>&#34;note 5&#34;</a>].</p>

<p>As each hunk is completed,
you will be told whether the hunk succeeded or failed,
and which line (in the new file) <i>patch</i> thought the hunk should go on.
If this is different from the line number specified in the diff you will be told the offset.
A single large offset MAY be an indication that a hunk was installed in the wrong place.
You will also be told if a fuzz factor was used to make the match,
in which case you should also be slightly suspicious.</p>

<p>If no original file is specified on the command line,
<i>patch</i> will try to figure out from the leading garbage what the name of the file to edit is.
In the header of a context diff,
the filename is found from lines beginning with &#34;***&#34; or &#34;---&#34;,
with the shortest name of an existing file winning.
Only context diffs have lines like that,
but if there is an &#34;Index:&#34; line in the leading garbage,
<i>patch</i> will try to use the filename from that line.
The context diff header takes precedence over an Index line.
If no filename can be intuited from the leading garbage,
you will be asked for the name of the file to patch.</p>

<p>No attempt is made to look up SCCS or RCS files [see <a href="#note_6" class="podlinkpod"
>&#34;note 6&#34;</a>].</p>

<p>Additionally,
if the leading garbage contains a &#34;Prereq: &#34; line,
<i>patch</i> will take the first word from the prerequisites line (normally a version number) and check the input file to see if that word can be found.
If not,
<i>patch</i> will ask for confirmation before proceeding.</p>

<p>The upshot of all this is that you should be able to say,
while in a news interface,
the following:</p>

<pre lang='und' xml:lang='und'>     | patch -d /usr/src/local/blurfl</pre>

<p>and patch a file in the blurfl directory directly from the article containing the patch.</p>

<p>If the patch file contains more than one patch, <i>patch</i> will try to apply each of them as if they came from separate patch files. This means, among other things, that it is assumed that the name of the file to patch must be determined for each diff listing, and that the garbage before each diff listing will be examined for interesting things such as filenames and revision level, as mentioned previously. You can give switches (and another original file name) for the second and subsequent patches by separating the corresponding argument lists by a &#39;+&#39;. (The argument list for a second or subsequent patch may not specify a new patch file, however.)</p>

<p><i>Patch</i> recognizes the following switches:</p>

<dl>
<dt><a name="-b_or_--suffix"
>-b or --suffix</a></dt><p class="pad"></p>

<dd>causes the next argument to be interpreted as the backup extension, to be used in place of &#34;.orig&#34; [see <a href="#note_1" class="podlinkpod"
>&#34;note 1&#34;</a>].</dd><p class="pad"></p>

<dt><a name="-B_or_--prefix"
>-B or --prefix</a></dt><p class="pad"></p>

<dd>causes the next argument to be interpreted as a prefix to the backup file name. If this argument is specified any argument from <b>-b</b> will be ignored.</dd><p class="pad"></p>

<dt><a name="-c_or_--context"
>-c or --context</a></dt><p class="pad"></p>

<dd>forces <i>patch</i> to interpret the patch file as a context diff.</dd><p class="pad"></p>

<dt><a name="-C_or_--check"
>-C or --check</a></dt><p class="pad"></p>

<dd>checks that the patch would apply cleanly, but does not modify anything.</dd><p class="pad"></p>

<dt><a name="-d_or_--directory"
>-d or --directory</a></dt><p class="pad"></p>

<dd>causes <i>patch</i> to interpret the next argument as a directory, and cd to it before doing anything else.</dd><p class="pad"></p>

<dt><a name="-D_or_--ifdef"
>-D or --ifdef</a></dt><p class="pad"></p>

<dd>causes <i>patch</i> to use the &#34;#ifdef...#endif&#34; construct to mark changes. The argument following will be used as the differentiating symbol. [see <a href="#note_7" class="podlinkpod"
>&#34;note 7&#34;</a>]</dd><p class="pad"></p>

<dt><a name="-e_or_--ed"
>-e or --ed</a></dt><p class="pad"></p>

<dd>forces <i>patch</i> to interpret the patch file as an ed script.</dd><p class="pad"></p>

<dt><a name="-E_or_--remove-empty-files"
>-E or --remove-empty-files</a></dt><p class="pad"></p>

<dd>causes <i>patch</i> to remove output files that are empty after the patches have been applied.</dd><p class="pad"></p>

<dt><a name="-f_or_--force"
>-f or --force</a></dt><p class="pad"></p>

<dd>forces <i>patch</i> to assume that the user knows exactly what he or she is doing, and to not ask any questions. It assumes the following: skip patches for which a file to patch can&#39;t be found; patch files even though they have the wrong version for the ``Prereq:&#39;&#39; line in the patch; and assume that patches are not reversed even if they look like they are. This option does not suppress commentary; use <b>-s</b> for that.</dd><p class="pad"></p>

<dt><a name="-t_or_--batch"
>-t or --batch</a></dt><p class="pad"></p>

<dd>similar to <b>-f</b>, in that it suppresses questions, but makes some different assumptions: skip patches for which a file to patch can&#39;t be found (the same as <b>-f</b>); skip patches for which the file has the wrong version for the ``Prereq:&#39;&#39; line in the patch; and assume that patches are reversed if they look like they are.</dd><p class="pad"></p>

<dt><a name="-Fnumber_or_--fuzz_number"
>-Fnumber or --fuzz number</a></dt><p class="pad"></p>

<dd>sets the maximum fuzz factor. This switch only applies to context diffs, and causes <i>patch</i> to ignore up to that many lines in looking for places to install a hunk. Note that a larger fuzz factor increases the odds of a faulty patch. The default fuzz factor is 2, and it may not be set to more than the number of lines of context in the context diff, ordinarily 3.</dd><p class="pad"></p>

<dt><a name="-l_or_--ignore-whitespace"
>-l or --ignore-whitespace</a></dt><p class="pad"></p>

<dd>causes the pattern matching to be done loosely, in case the tabs and spaces have been munged in your input file. Any sequence of whitespace in the pattern line will match any sequence in the input file. Normal characters must still match exactly. Each line of the context must still match a line in the input file.</dd><p class="pad"></p>

<dt><a name="-n_or_--normal"
>-n or --normal</a></dt><p class="pad"></p>

<dd>forces <i>patch</i> to interpret the patch file as a normal diff.</dd><p class="pad"></p>

<dt><a name="-N_or_--forward"
>-N or --forward</a></dt><p class="pad"></p>

<dd>causes <i>patch</i> to ignore patches that it thinks are reversed or already applied. See also <b>-R .</b></dd><p class="pad"></p>

<dt><a name="-o_or_--output"
>-o or --output</a></dt><p class="pad"></p>

<dd>causes the next argument to be interpreted as the output file name.</dd><p class="pad"></p>

<dt><a name="-pnumber_or_--strip_number"
>-pnumber or --strip number</a></dt><p class="pad"></p>

<dd>sets the pathname strip count, which controls how pathnames found in the patch file are treated, in case the you keep your files in a different directory than the person who sent out the patch. The strip count specifies how many slashes are to be stripped from the front of the pathname. (Any intervening directory names also go away.) For example, supposing the filename in the patch file was</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   /i/want/a/moogle/stuffy</pre>

<dd>setting <b>-p</b> or <b>-p0</b> gives the entire pathname unmodified, <b>-p1</b> gives</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   i/want/a/moogle/stuff</pre>

<dd>without the leading slash, <b>-p4</b> gives</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   moogle/stuffy</pre>

<dd>and not specifying <b>-p</b> at all just gives you &#34;stuffy&#34;, unless all of the directories in the leading path (i/want/a/moogle) exist and that path is relative, in which case you get the entire pathname unmodified. Whatever you end up with is looked for either in the current directory, or the directory specified by the <b>-d</b> switch.</dd><p class="pad"></p>

<dt><a name="-r_or_--reject-file"
>-r or --reject-file</a></dt><p class="pad"></p>

<dd>causes the next argument to be interpreted as the reject file name.</dd><p class="pad"></p>

<dt><a name="-R_or_--reverse"
>-R or --reverse</a></dt><p class="pad"></p>

<dd>tells <i>patch</i> that this patch was created with the old and new files swapped. (Yes, I&#39;m afraid that does happen occasionally, human nature being what it is.) <i>Patch</i> will attempt to swap each hunk around before applying it. Rejects will come out in the swapped format. The <b>-R</b> switch will not work with ed diff scripts because there is too little information to reconstruct the reverse operation.</dd><p class="pad"></p>

<dd>If the first hunk of a patch fails, <i>patch</i> will reverse the hunk to see if it can be applied that way. If it can, you will be asked if you want to have the <b>-R</b> switch set. If it can&#39;t, the patch will continue to be applied normally. (Note: this method cannot detect a reversed patch if it is a normal diff and if the first command is an append (i.e. it should have been a delete) since appends always succeed, due to the fact that a null context will match anywhere. Luckily, most patches add or change lines rather than delete them, so most reversed normal diffs will begin with a delete, which will fail, triggering the heuristic.)</dd><p class="pad"></p>

<dt><a name="-s_or_--quiet_or_--silent"
>-s or --quiet or --silent</a></dt><p class="pad"></p>

<dd>makes <i>patch</i> do its work silently, unless an error occurs.</dd><p class="pad"></p>

<dt><a name="-S_or_--skip"
>-S or --skip</a></dt><p class="pad"></p>

<dd>causes <i>patch</i> to ignore this patch from the patch file, but continue on looking for the next patch in the file. Thus</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   patch -S + -S + &#60; patchfile</pre>

<dd>will ignore the first and second of three patches.</dd><p class="pad"></p>

<dt><a name="-u_or_--unified"
>-u or --unified</a></dt><p class="pad"></p>

<dd>forces <i>patch</i> to interpret the patch file as a unified context diff (a unidiff).</dd><p class="pad"></p>

<dt><a name="-v_or_--version"
>-v or --version</a></dt><p class="pad"></p>

<dd>causes <i>patch</i> to print out its revision header and patch level.</dd><p class="pad"></p>

<dt><a name="-V_or_--version-control"
>-V or --version-control</a></dt><p class="pad"></p>

<dd>causes the next argument to be interpreted as a method for creating backup file names. The type of backups made can also be given in the <b>VERSION</b><i>_</i><b>CONTROL</b> environment variable, which is overridden by this option. The <b>-B</b> option overrides this option, causing the prefix to always be used for making backup file names. The value of the <b>VERSION</b><i>_</i><b>CONTROL</b> environment variable and the argument to the <b>-V</b> option are like the GNU Emacs `version-control&#39; variable; they also recognize synonyms that are more descriptive. The valid values are (unique abbreviations are accepted):</dd><p class="pad"></p>

<dl>
<dt><a name="`t&#39;_or_`numbered&#39;"
>`t&#39; or `numbered&#39;</a></dt><p class="pad"></p>

<dd>Always make numbered backups.</dd><p class="pad"></p>

<dt><a name="`nil&#39;_or_`existing&#39;"
>`nil&#39; or `existing&#39;</a></dt><p class="pad"></p>

<dd>Make numbered backups of files that already have them, simple backups of the others. This is the default.</dd><p class="pad"></p>

<dt><a name="`never&#39;_or_`simple&#39;"
>`never&#39; or `simple&#39;</a></dt><p class="pad"></p>

<dd>Always make simple backups.</dd><p class="pad"></p>
</dl>

<dt><a name="-xnumber_or_--debug_number"
>-xnumber or --debug number</a></dt><p class="pad"></p>

<dd>sets internal debugging flags, and is of no interest to <i>patch</i> patchers [see <a href="#note_8" class="podlinkpod"
>&#34;note 8&#34;</a>].</dd><p class="pad"></p>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ENVIRONMENT"
>ENVIRONMENT</a></h1>

<p><b>SIMPLE_BACKUP_SUFFIX</b> Extension to use for backup file names instead of &#34;.orig&#34; or &#34;~&#34;.</p>

<p><b>VERSION_CONTROL</b> Selects when numbered backup files are made.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>diff(1), ed(1)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES_FOR_PATCH_SENDERS"
>NOTES FOR PATCH SENDERS</a></h1>

<p>There are several things you should bear in mind if you are going to be sending out patches. First, you can save people a lot of grief by keeping a patchlevel.h file which is patched to increment the patch level as the first diff in the patch file you send out. If you put a Prereq: line in with the patch, it won&#39;t let them apply patches out of order without some warning. Second, make sure you&#39;ve specified the filenames right, either in a context diff header, or with an Index: line. If you are patching something in a subdirectory, be sure to tell the patch user to specify a <b>-p</b> switch as needed. Third, you can create a file by sending out a diff that compares a null file to the file you want to create. This will only work if the file you want to create doesn&#39;t exist already in the target directory. Fourth, take care not to send out reversed patches, since it makes people wonder whether they already applied the patch. Fifth, while you may be able to get away with putting 582 diff listings into one file, it is probably wiser to group related patches into separate files in case something goes haywire.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DIAGNOSTICS"
>DIAGNOSTICS</a></h1>

<p>Too many to list here, but generally indicative that <i>patch</i> couldn&#39;t parse your patch file.</p>

<p>The message &#34;Hmm...&#34; indicates that there is unprocessed text in the patch file and that <i>patch</i> is attempting to intuit whether there is a patch in that text and, if so, what kind of patch it is.</p>

<p><i>Patch</i> will exit with a non-zero status if any reject files were created. When applying a set of patches in a loop it behooves you to check this exit status so you don&#39;t apply a later patch to a partially patched file.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p><i>Patch</i> cannot tell if the line numbers are off in an ed script, and can only detect bad line numbers in a normal diff when it finds a &#34;change&#34; or a &#34;delete&#34; command. A context diff using fuzz factor 3 may have the same problem. Until a suitable interactive interface is added, you should probably do a context diff in these cases to see if the changes made sense. Of course, compiling without errors is a pretty good indication that the patch worked, but not always.</p>

<p><i>Patch</i> usually produces the correct results, even when it has to do a lot of guessing. However, the results are guaranteed to be correct only when the patch is applied to exactly the same version of the file that the patch was generated from.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Could be smarter about partial matches, excessively deviant offsets and swapped code, but that would take an extra pass.</p>

<p>Check patch mode ( <b>-C</b>) will fail if you try to check several patches in succession that build on each other. The whole code of <i>patch</i> would have to be restructured to keep temporary files around so that it can handle this situation.</p>

<p>If code has been duplicated (for instance with #ifdef OLDCODE ... #else ... #endif), <i>patch</i> is incapable of patch- ing both versions, and, if it works at all, will likely patch the wrong one, and tell you that it succeeded to boot.</p>

<p>If you apply a patch you&#39;ve already applied, <i>patch</i> will think it is a reversed patch, and offer to un-apply the patch. This could be construed as a feature.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMPATIBILITY"
>COMPATIBILITY</a></h1>

<p>The perl implementation of patch is based on but not entire compatible with the documentation for GNU patch version 2.1:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_1"
>note 1</a></h2>

<p>On systems that do not support long filenames, GNU patch uses the extension &#34;~&#34; for backup files and the extension &#34;#&#34; for reject files. How to know if a system support long filenames?</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_2"
>note 2</a></h2>

<p>Only new-style context diffs are supported. What does old-style context diff look like?</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_3"
>note 3</a></h2>

<p>If the pipe to ed fails, <b>patch</b> will attempt to apply the ed script on its own.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_4"
>note 4</a></h2>

<p>This algorithm differs from the one described in the documentation for GNU patch, which scans forwards and backwards from the line number mentioned in the diff (plus any offset used in applying the previous hunk).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_5"
>note 5</a></h2>

<p>Rejected hunks in GNU patch all come out as context diffs regardless of the input diff, and the lines numbers reflect the approximate location GNU patch thinks the failed hunks belong in the new file rather than the old one.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_6"
>note 6</a></h2>

<p>If the original file cannot be found or is read-only, but a suitable SCCS or RCS file is handy, GNU patch will attempt to get or check out the file.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_7"
>note 7</a></h2>

<p>GNU patch requires a space between the <b>-D</b> and the argument. This has been made optional.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="note_8"
>note 8</a></h2>

<p>There are currently no debugging flags to go along with <b>-x</b>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Tim Gim Yee | tgy@chocobo.org | I want a moogle stuffy!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 1999 Moogle Stuffy Software. All rights reserved.</p>

<p>You may play with this software in accordance with the Perl Artistic License.</p>

<p>You may use this documentation under the auspices of the GNU General Public License.</p>

<!-- end doc -->

</body></html>
